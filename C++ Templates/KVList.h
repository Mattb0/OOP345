#pragma once

// Templates handle can handle multiple types of data
// For example, if you create a function that can only handle 1 data
// and if we are building multiple functions that do the exact same thing
// you can create a template
// **You cannot have 2 different types of data. i.e. double int unless you do some changes.
// To create templates, a template definition has to be created.


template <typename K, typename V, int N>

// typename can be any data type
class KVList
{

	//The classes generated by your template contain two parallel arrays of dimension N - a key array of type K and a value array of type V.  K, V and N are template parameters 
	K  varK[N];
	V  varV[N];
	size t count = 0;  //  number of entiries

public:

	KVList() // default constructor - adopts a safe empty state
	{
		// count = 0; // c++ 98 
	}


	size_t size() const // const - returns the number of entires in the key-value list
	{

		return count;
	}


	const K& key (int i) const // returns an unmodifiable reference to the key of element i in the list
	{
		if (i < count)
		{
			return varK[i];
		}
	}


	const V& value(int i) const //  returns an unmodifiable reference to the value of element i in the list
	{
		if (i < count)
		{
			return varV[i];
		}
	}


	KVList& add(const K& kk, const V& vv) // adds a new element to the list if room exists and returns a reference to the current object, does nothing if no room exists
	{
			if (count < N)
			{
				varK[count] = kk;
				varV[count] = vv;
				return *this;
			}
	}



	int find(const K& kk) // returns the index of the first element in the list with a key equal to k - defaults to 0
	{ 
		for (size_t i = 0; i < count; i++)
		{
			if (varK[i] == kk[i])
			{
				return i; // returns the index of the first element
			}
		}
		return 0;
	}

	
	KVList& replace (int i, const K& kk, const V& vv) // replaces element i in the list with the key and value received and returns a reference to the current object
	{

		if (i < count)
		{
			varK[i] = kk;
			varV[i] = vv;
		}
		return *this; // returns a reference to the current object
		
	}

};